import os
import numpy as np
from osgeo import gdal
from PyQt5.QtCore import QObject, pyqtSignal

class VulnerabilityMap(QObject):
    progress_updated = pyqtSignal(int)
    def __init__(self):
        super(VulnerabilityMap, self).__init__()
        self.data_folder = None
        self.initial_directory = None

    def set_working_directory(self, directory):
        '''
        Set up the working directory
        :param directory: your local directory with all dat files
        '''
        self.progress_updated.emit(0)
        # self.initial_directory = os.getcwd()
        self.data_folder = directory
        os.chdir(self.data_folder)

    def image_to_array(self,image):
        # Set up a GDAL dataset
        in_ds = gdal.Open(image)
        # Set up a GDAL band
        in_band = in_ds.GetRasterBand(1)
        # Create Numpy Array1
        arr = in_band.ReadAsArray()
        return arr

    def nrt_calculation(self, in_fn, deforestation_hrp, mask):
        '''
        NRT calculation
        :param in_fn: map of distance from the forest eddge in CAL
        :param deforestation_hrp:deforestation binary map in HRP
        :param mask: mask of the jurisdiction (binary map)
        :return: NRT: Negligible Risk Threshold
        '''
        # Convert image to NumPy array
        self.progress_updated.emit(10)
        distance_arr_cal = self.image_to_array(in_fn)
        self.progress_updated.emit(30)
        deforestation_hrp_arr = self.image_to_array(deforestation_hrp)
        self.progress_updated.emit(40)
        mask_arr = self.image_to_array(mask)
        self.progress_updated.emit(50)

        # Mask the distance arr within deforstation pixel and study area
        distance_arr_masked=distance_arr_cal*mask_arr*deforestation_hrp_arr
        self.progress_updated.emit(60)

        ## Calculate the histogram
        # Flatten the distance_arr_masked and expect 0 for np.histogram function
        # The np.histogram is computed over the flattened array
        distance_arr_masked_1d = distance_arr_masked.flatten()
        self.progress_updated.emit(80)
        distance_arr_masked_1d = distance_arr_masked_1d[distance_arr_masked_1d != 0]

        ## Calculate the histogram
        # Set up bin width as spatial resolution
        in_ds = gdal.Open(in_fn)
        P = in_ds.GetGeoTransform()[1]
        bin_width =int(P)
        # Calculate the histogram
        hist, bin_edges = np.histogram(distance_arr_masked_1d, bins=np.arange(distance_arr_masked_1d.min(),
                                                                              distance_arr_masked_1d.max() + bin_width,
                                                                               bin_width))
        # Calculate the cumulative proportion
        # Normalize the histogram to get probability
        hist_normalized = hist / np.sum(hist)

        # Compute cumulative distribution
        cumulative_prop = np.cumsum(hist_normalized)

        # # Find the index cumulative proportion >= 0.995
        index_995 = np.argmax(cumulative_prop >= 0.995)

        # Get the bin edges for the NRT bin
        nrt_bin_start = bin_edges[index_995]
        nrt_bin_end = bin_edges[index_995 + 1]
        self.progress_updated.emit(90)

        # Calculate the average of the NRT bin
        NRT = int((nrt_bin_start + nrt_bin_end) / 2)
        self.progress_updated.emit(100)
        return NRT

    def geometric_classification(self, in_fn, NRT, n_classes):
        '''
        geometric classification
        :param in_fn: map of distance from the forest eddge
        :param NRT:Negligible Risk Threshold
        :param n_classes:number of classes
        :return: mask_arr: result array with mask larger than NRT
        '''
        # Convert in_fn to NumPy array
        # Set up a GDAL dataset
        in_ds = gdal.Open(in_fn)
        # Set up a GDAL band
        in_band = in_ds.GetRasterBand(1)
        # Create Numpy Array
        arr = in_band.ReadAsArray()

        # The lower limit of the highest class = spatial resolution (the minimum distance possible without being in non-forest)
        LL = int(in_ds.GetGeoTransform()[1])

        self.progress_updated.emit(10)
        # The upper limit of the lowest class = the Negligible Risk Threshold
        UL = NRT = int(NRT)
        n_classes = int(n_classes)

        # Calculate common ratio(r)=(LLmax/LLmin)^1/n_classes
        r = np.power(LL / UL, 1/n_classes)

        # Create 2D class_array for the areas within the NRT
        class_array = np.array([[i, i + 1] for i in range(n_classes)])

        # Calculate UL and LL value for the areas within the NRT
        x= np.power(r, class_array)
        risk_class=np.multiply(UL,x)

        self.progress_updated.emit(20)
        # Create mask: areas beyond the NRT, assign class 1
        mask_arr = np.ma.masked_where(arr >= NRT , arr)
        mask_arr = mask_arr.filled(1)

        self.progress_updated.emit(30)
        # Reclassification mask_arr value >= LL into risk_class
        # (e.g., if n_class is 29, class the areas within the NRT into class 2 to 30)
        index=0
        for UL, LL in risk_class:
            mask_arr[np.where((UL > mask_arr) & (mask_arr >= LL))] = index+2
            index+=1
            # Emit progress signals of 50 and 70
            if index == int(n_classes/2):
                self.progress_updated.emit(50)
            elif index == int(n_classes):
                self.progress_updated.emit(70)

        self.progress_updated.emit(80)
        return mask_arr

    def array2raster(self, in_fn, out_fn, data, data_type, nodata=None):
        '''
        Create 30-class Vulerability Map
        :param in_fn: map of distance from the forest eddge
        :param out_fn: path to the file to create
        :param data: NumPy array containing data to write
        :param data_type: output data type
        :param nodata: optional NoData value
        :return: out_ds
        '''
        in_ds = gdal.Open(in_fn)
        output_format = in_fn.split('.')[-1].upper()
        if (output_format == 'TIF'):
            output_format = 'GTIFF'
        elif (output_format == 'RST'):
            output_format = 'rst'
        driver = gdal.GetDriverByName(output_format)
        out_ds = driver.Create(out_fn, in_ds.RasterXSize, in_ds.RasterYSize, 1, data_type, options=["BigTIFF=YES"])
        out_ds.SetProjection(in_ds.GetProjection())
        out_ds.SetGeoTransform(in_ds.GetGeoTransform())
        out_band = out_ds.GetRasterBand(1)
        if nodata is not None:
            out_band.SetNoDataValue(nodata)
        out_band.WriteArray(data)
        out_band.FlushCache()
        # Compute actual statistics include mean, minimum, maximum, and standard deviation.
        out_band.ComputeStatistics(False)
        self.progress_updated.emit(100)
        return out_ds

